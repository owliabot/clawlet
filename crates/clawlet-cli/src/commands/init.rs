//! `clawlet init` ‚Äî set up a new clawlet instance.
//!
//! Creates the data directory, generates a keystore, writes default
//! config.yaml and policy.yaml, and prints the wallet address.
//!
//! The keystore password is also used for API authentication. When granting
//! session tokens to AI agents, the keystore password must be provided to
//! verify authorization.

use std::path::PathBuf;

use clawlet_signer::hd;
use clawlet_signer::keystore::Keystore;

/// Default policy YAML template.
const DEFAULT_POLICY: &str = r#"# Clawlet transfer policy
# Edit this file to configure spending limits and allowlists.

daily_transfer_limit_usd: 1000.0
per_tx_limit_usd: 500.0

# Allowed token symbols (empty = all tokens allowed)
allowed_tokens: []

# Allowed chain IDs (empty = all chains allowed)
allowed_chains: []

# Transfers above this USD value require human approval (remove to disable)
require_approval_above_usd: 200.0
"#;

/// Build the default config.yaml content, pointing at the given data directory.
fn default_config(data_dir: &std::path::Path) -> String {
    let policy_path = data_dir.join("policy.yaml");
    let keystore_path = data_dir.join("keystore");
    let audit_log_path = data_dir.join("audit.jsonl");

    format!(
        r#"# Clawlet configuration
# Generated by `clawlet init`

policy_path: "{}"
keystore_path: "{}"
rpc_bind: "127.0.0.1:9100"
audit_log_path: "{}"

# Map chain IDs to RPC endpoints
# Replace with your own RPC URLs for better reliability/performance
chain_rpc_urls:
  # Ethereum Mainnet
  1: "https://eth.llamarpc.com"
  # Base
  8453: "https://mainnet.base.org"
  # Arbitrum One
  42161: "https://arb1.arbitrum.io/rpc"
  # Optimism
  10: "https://mainnet.optimism.io"
  # Polygon
  137: "https://polygon-rpc.com"
  # BNB Smart Chain
  56: "https://bsc-dataseed.binance.org"
  # Sepolia (testnet)
  11155111: "https://ethereum-sepolia-rpc.publicnode.com"

# Authentication configuration
# Password verification uses your keystore password - no separate auth password needed.
# When granting session tokens, provide your keystore password for verification.
auth:
  default_session_ttl_hours: 24
  max_failed_attempts: 5
  lockout_minutes: 15
"#,
        policy_path.display(),
        keystore_path.display(),
        audit_log_path.display(),
    )
}

/// Run the `init` subcommand.
pub fn run(
    from_mnemonic: bool,
    data_dir: Option<PathBuf>,
) -> Result<(), Box<dyn std::error::Error>> {
    let data_dir = super::resolve_data_dir(data_dir)?;

    // Ensure directory structure exists
    let keystore_dir = data_dir.join("keystore");
    std::fs::create_dir_all(&data_dir)?;
    std::fs::create_dir_all(&keystore_dir)?;

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        std::fs::set_permissions(&data_dir, std::fs::Permissions::from_mode(0o700))?;
        std::fs::set_permissions(&keystore_dir, std::fs::Permissions::from_mode(0o700))?;
    }

    // Prompt for keystore password (also used for auth)
    eprintln!("== Keystore & Authentication Setup ==");
    eprintln!();
    eprintln!("This password encrypts your private key AND authenticates API requests.");
    eprintln!("When granting session tokens to AI agents, you'll use this same password.");
    eprintln!();

    let password = {
        let mut attempts: usize = 0;
        loop {
            attempts += 1;
            if attempts > 5 {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidInput,
                    "password entry failed: too many attempts",
                )
                .into());
            }

            let password = rpassword::prompt_password_stderr("Enter password: ")?;
            if password.is_empty() {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::UnexpectedEof,
                    "password entry aborted (empty input/EOF)",
                )
                .into());
            }

            let issues = validate_password_strength(&password);
            if !issues.is_empty() {
                eprintln!("Password does not meet requirements:");
                for issue in &issues {
                    eprintln!("  - {issue}");
                }
                eprintln!();
                continue;
            }

            let confirm = rpassword::prompt_password_stderr("Confirm password: ")?;
            if confirm.is_empty() {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::UnexpectedEof,
                    "password confirmation aborted (empty input/EOF)",
                )
                .into());
            }
            if password != confirm {
                eprintln!("Passwords do not match. Please try again.");
                eprintln!();
                continue;
            }

            break password;
        }
    };

    let address = if from_mnemonic {
        // Prompt for existing mnemonic in private mode (input hidden)
        let mnemonic = rpassword::prompt_password_stderr("Enter your BIP-39 mnemonic phrase: ")?;
        let mnemonic = mnemonic.trim().to_string();
        if mnemonic.is_empty() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                "mnemonic entry aborted (empty input/EOF)",
            )
            .into());
        }

        // Store the mnemonic in the keystore
        let (address, _path) = Keystore::create_from_mnemonic(&keystore_dir, &password, &mnemonic)?;

        #[cfg(unix)]
        set_keystore_file_permissions(&keystore_dir)?;

        address
    } else {
        // Generate a new mnemonic and show it in alternate screen
        let mnemonic = hd::generate_mnemonic();

        crate::tui::show_sensitive(
            &[
                "üîë Generated mnemonic (WRITE THIS DOWN ‚Äî it will NOT be shown again):",
                "",
                &format!("  {mnemonic}"),
            ],
            "Press Enter when you have saved the mnemonic...",
        )?;

        // Store the mnemonic in the keystore
        let (address, _path) = Keystore::create_from_mnemonic(&keystore_dir, &password, &mnemonic)?;

        #[cfg(unix)]
        set_keystore_file_permissions(&keystore_dir)?;

        address
    };

    // Write default policy.yaml
    let policy_path = data_dir.join("policy.yaml");
    if !policy_path.exists() {
        std::fs::write(&policy_path, DEFAULT_POLICY)?;
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            std::fs::set_permissions(&policy_path, std::fs::Permissions::from_mode(0o600))?;
        }
    }

    // Write default config.yaml
    let config_path = data_dir.join("config.yaml");
    if !config_path.exists() {
        std::fs::write(&config_path, default_config(&data_dir))?;
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            std::fs::set_permissions(&config_path, std::fs::Permissions::from_mode(0o600))?;
        }
    }

    eprintln!();
    println!(
        "Initialized clawlet at {} ‚Äî address: {address}",
        data_dir.display()
    );

    eprintln!();
    eprintln!("üîê To grant a session token to an AI agent:");
    eprintln!("   clawlet auth grant --agent <name> --scope <read|trade|admin>");
    eprintln!();
    eprintln!("   You'll be prompted for the keystore password to authorize the grant.");

    Ok(())
}

/// Validate password strength, returning a list of unmet requirements.
pub(crate) fn validate_password_strength(password: &str) -> Vec<&'static str> {
    let mut issues = Vec::new();
    if password.chars().count() < 8 {
        issues.push("must be at least 8 characters");
    }
    if !password.chars().any(|c| c.is_ascii_uppercase()) {
        issues.push("must contain at least 1 uppercase letter");
    }
    if !password.chars().any(|c| c.is_ascii_lowercase()) {
        issues.push("must contain at least 1 lowercase letter");
    }
    if !password.chars().any(|c| c.is_ascii_digit()) {
        issues.push("must contain at least 1 digit");
    }
    if !password.chars().any(|c| !c.is_alphanumeric()) {
        issues.push("must contain at least 1 symbol (non-alphanumeric character)");
    }
    issues
}

/// Set keystore files to 0600.
#[cfg(unix)]
fn set_keystore_file_permissions(
    keystore_dir: &std::path::Path,
) -> Result<(), Box<dyn std::error::Error>> {
    use std::os::unix::fs::PermissionsExt;
    for entry in std::fs::read_dir(keystore_dir)? {
        let entry = entry?;
        if entry.path().is_file() {
            std::fs::set_permissions(entry.path(), std::fs::Permissions::from_mode(0o600))?;
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::validate_password_strength;

    #[test]
    fn password_strength_empty() {
        let issues = validate_password_strength("");
        assert!(issues.contains(&"must be at least 8 characters"));
        assert!(issues.contains(&"must contain at least 1 uppercase letter"));
        assert!(issues.contains(&"must contain at least 1 lowercase letter"));
        assert!(issues.contains(&"must contain at least 1 digit"));
        assert!(issues.contains(&"must contain at least 1 symbol (non-alphanumeric character)"));
    }

    #[test]
    fn password_strength_too_short() {
        let issues = validate_password_strength("Aa1!aaa"); // 7 chars
        assert_eq!(issues, vec!["must be at least 8 characters"]);
    }

    #[test]
    fn password_strength_missing_uppercase() {
        let issues = validate_password_strength("aa1!aaaa");
        assert!(issues.contains(&"must contain at least 1 uppercase letter"));
    }

    #[test]
    fn password_strength_missing_lowercase() {
        let issues = validate_password_strength("AA1!AAAA");
        assert!(issues.contains(&"must contain at least 1 lowercase letter"));
    }

    #[test]
    fn password_strength_missing_digit() {
        let issues = validate_password_strength("Aa!aaaaa");
        assert!(issues.contains(&"must contain at least 1 digit"));
    }

    #[test]
    fn password_strength_missing_symbol() {
        let issues = validate_password_strength("Aa1aaaaa");
        assert!(issues.contains(&"must contain at least 1 symbol (non-alphanumeric character)"));
    }

    #[test]
    fn password_strength_valid() {
        let issues = validate_password_strength("Aa1!aaaa");
        assert!(issues.is_empty());
    }
}
