//! `clawlet init` ‚Äî set up a new clawlet instance.
//!
//! Creates the data directory, generates a keystore, writes default
//! config.yaml and policy.yaml, and prints the wallet address.
//!
//! The keystore password is also used for API authentication. When granting
//! session tokens to AI agents, the keystore password must be provided to
//! verify authorization.

use std::path::PathBuf;

use clawlet_signer::hd;
use clawlet_signer::keystore::Keystore;

/// Default policy YAML template.
const DEFAULT_POLICY: &str = r#"# Clawlet transfer policy
# Edit this file to configure spending limits and allowlists.

daily_transfer_limit_usd: 1000.0
per_tx_limit_usd: 500.0

# Allowed token symbols (empty = all tokens allowed)
allowed_tokens: []

# Allowed chain IDs (empty = all chains allowed)
allowed_chains: []

# Transfers above this USD value require human approval (remove to disable)
require_approval_above_usd: 200.0
"#;

/// Build the default config.yaml content, pointing at the given data directory.
fn default_config(data_dir: &std::path::Path) -> String {
    let policy_path = data_dir.join("policy.yaml");
    let keystore_path = data_dir.join("keystore");
    let audit_log_path = data_dir.join("audit.jsonl");

    format!(
        r#"# Clawlet configuration
# Generated by `clawlet init`

policy_path: "{}"
keystore_path: "{}"
rpc_bind: "127.0.0.1:9100"
audit_log_path: "{}"

# Map chain IDs to RPC endpoints
# Replace with your own RPC URLs for better reliability/performance
chain_rpc_urls:
  # Ethereum Mainnet
  1: "https://eth.llamarpc.com"
  # Base
  8453: "https://mainnet.base.org"
  # Arbitrum One
  42161: "https://arb1.arbitrum.io/rpc"
  # Optimism
  10: "https://mainnet.optimism.io"
  # Polygon
  137: "https://polygon-rpc.com"
  # BNB Smart Chain
  56: "https://bsc-dataseed.binance.org"

# Authentication configuration
# Password verification uses your keystore password - no separate auth password needed.
# When granting session tokens, provide your keystore password for verification.
auth:
  default_session_ttl_hours: 24
  max_failed_attempts: 5
  lockout_minutes: 15
"#,
        policy_path.display(),
        keystore_path.display(),
        audit_log_path.display(),
    )
}

/// Resolve the data directory (default: ~/.clawlet).
fn resolve_data_dir(data_dir: Option<PathBuf>) -> Result<PathBuf, Box<dyn std::error::Error>> {
    if let Some(dir) = data_dir {
        return Ok(dir);
    }

    let home = dirs::home_dir().ok_or("could not determine home directory")?;
    Ok(home.join(".clawlet"))
}

/// Run the `init` subcommand.
pub fn run(
    from_mnemonic: bool,
    data_dir: Option<PathBuf>,
) -> Result<(), Box<dyn std::error::Error>> {
    let data_dir = resolve_data_dir(data_dir)?;

    // Ensure directory structure exists
    let keystore_dir = data_dir.join("keystore");
    std::fs::create_dir_all(&keystore_dir)?;

    // Prompt for keystore password (also used for auth)
    eprintln!("== Keystore & Authentication Setup ==");
    eprintln!();
    eprintln!("This password encrypts your private key AND authenticates API requests.");
    eprintln!("When granting session tokens to AI agents, you'll use this same password.");
    eprintln!();
    eprint!("Enter password: ");
    let password = rpassword::read_password()?;
    eprint!("Confirm password: ");
    let confirm = rpassword::read_password()?;
    if password != confirm {
        return Err("passwords do not match".into());
    }

    let address = if from_mnemonic {
        // Prompt for existing mnemonic
        eprintln!();
        eprintln!("Enter your BIP-39 mnemonic phrase:");
        let mut mnemonic = String::new();
        std::io::stdin().read_line(&mut mnemonic)?;
        let mnemonic = mnemonic.trim();

        // Store the mnemonic in the keystore
        let (address, _path) = Keystore::create_from_mnemonic(&keystore_dir, &password, mnemonic)?;

        #[cfg(unix)]
        set_keystore_file_permissions(&keystore_dir)?;

        address
    } else {
        // Generate a new mnemonic
        let mnemonic = hd::generate_mnemonic();
        eprintln!();
        eprintln!("üîë Generated mnemonic (WRITE THIS DOWN ‚Äî it will NOT be shown again):");
        eprintln!();
        eprintln!("  {mnemonic}");
        eprintln!();

        // Store the mnemonic in the keystore
        let (address, _path) = Keystore::create_from_mnemonic(&keystore_dir, &password, &mnemonic)?;

        #[cfg(unix)]
        set_keystore_file_permissions(&keystore_dir)?;

        address
    };

    // Write default policy.yaml
    let policy_path = data_dir.join("policy.yaml");
    if !policy_path.exists() {
        std::fs::write(&policy_path, DEFAULT_POLICY)?;
    }

    // Write default config.yaml
    let config_path = data_dir.join("config.yaml");
    if !config_path.exists() {
        std::fs::write(&config_path, default_config(&data_dir))?;
    }

    eprintln!();
    println!(
        "Initialized clawlet at {} ‚Äî address: {address}",
        data_dir.display()
    );

    eprintln!();
    eprintln!("üîê To grant a session token to an AI agent:");
    eprintln!("   clawlet auth grant --agent <name> --scope <read|trade|admin>");
    eprintln!();
    eprintln!("   You'll be prompted for the keystore password to authorize the grant.");

    Ok(())
}

/// Set keystore files to 0600.
#[cfg(unix)]
fn set_keystore_file_permissions(
    keystore_dir: &std::path::Path,
) -> Result<(), Box<dyn std::error::Error>> {
    use std::os::unix::fs::PermissionsExt;
    for entry in std::fs::read_dir(keystore_dir)? {
        let entry = entry?;
        if entry.path().is_file() {
            std::fs::set_permissions(entry.path(), std::fs::Permissions::from_mode(0o600))?;
        }
    }
    Ok(())
}
