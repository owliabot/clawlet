//! `clawlet init` ‚Äî set up a new clawlet instance.
//!
//! Creates the data directory, generates a keystore, writes default
//! config.yaml and policy.yaml, and prints the wallet address.

use std::path::PathBuf;

use clawlet_core::auth;
use clawlet_signer::hd;
use clawlet_signer::keystore::Keystore;

/// Default policy YAML template.
const DEFAULT_POLICY: &str = r#"# Clawlet transfer policy
# Edit this file to configure spending limits and allowlists.

daily_transfer_limit_usd: 1000.0
per_tx_limit_usd: 500.0

# Allowed token symbols (empty = all tokens allowed)
allowed_tokens: []

# Allowed chain IDs (empty = all chains allowed)
allowed_chains: []

# Transfers above this USD value require human approval (remove to disable)
require_approval_above_usd: 200.0
"#;

/// Build the default config.yaml content, pointing at the given data directory.
fn default_config(data_dir: &std::path::Path, auth_password_hash: Option<&str>) -> String {
    let policy_path = data_dir.join("policy.yaml");
    let keystore_path = data_dir.join("keystore");
    let audit_log_path = data_dir.join("audit.jsonl");

    let auth_section = if let Some(hash) = auth_password_hash {
        format!(
            r#"
# Authentication configuration
auth:
  password_hash: "{}"
  default_session_ttl_hours: 24
  max_failed_attempts: 5
  lockout_minutes: 15
"#,
            hash
        )
    } else {
        r#"
# Authentication configuration (no password set - all requests allowed)
# Run `clawlet init` with auth password to enable authentication
auth: {}
"#
        .to_string()
    };

    format!(
        r#"# Clawlet configuration
# Generated by `clawlet init`

policy_path: "{}"
keystore_path: "{}"
rpc_bind: "127.0.0.1:9100"
audit_log_path: "{}"

# Map chain IDs to RPC endpoints
chain_rpc_urls: {{}}
{}"#,
        policy_path.display(),
        keystore_path.display(),
        audit_log_path.display(),
        auth_section,
    )
}

/// Resolve the data directory (default: ~/.clawlet).
fn resolve_data_dir(data_dir: Option<PathBuf>) -> Result<PathBuf, Box<dyn std::error::Error>> {
    if let Some(dir) = data_dir {
        return Ok(dir);
    }

    let home = dirs::home_dir().ok_or("could not determine home directory")?;
    Ok(home.join(".clawlet"))
}

/// Run the `init` subcommand.
pub fn run(
    from_mnemonic: bool,
    data_dir: Option<PathBuf>,
) -> Result<(), Box<dyn std::error::Error>> {
    let data_dir = resolve_data_dir(data_dir)?;

    // Ensure directory structure exists
    let keystore_dir = data_dir.join("keystore");
    std::fs::create_dir_all(&keystore_dir)?;

    // Prompt for keystore password
    eprintln!("== Keystore Setup ==");
    eprint!("Enter password for keystore encryption: ");
    let password = rpassword::read_password()?;
    eprint!("Confirm password: ");
    let confirm = rpassword::read_password()?;
    if password != confirm {
        return Err("passwords do not match".into());
    }

    // Prompt for auth password (optional but recommended)
    eprintln!();
    eprintln!("== Authentication Setup ==");
    eprintln!("Set a password for granting session tokens to AI agents.");
    eprintln!("(Press Enter to skip - NOT RECOMMENDED for production)");
    eprintln!();
    eprint!("Enter auth password: ");
    let auth_password = rpassword::read_password()?;

    let auth_password_hash = if auth_password.is_empty() {
        eprintln!();
        eprintln!(
            "‚ö†Ô∏è  No auth password set. All API requests will be allowed without authentication."
        );
        eprintln!("   You can set a password later by editing config.yaml.");
        None
    } else {
        eprint!("Confirm auth password: ");
        let auth_confirm = rpassword::read_password()?;
        if auth_password != auth_confirm {
            return Err("auth passwords do not match".into());
        }

        // Hash the auth password
        let hash = auth::hash_password(&auth_password)?;
        Some(hash)
    };

    let address = if from_mnemonic {
        // Prompt for existing mnemonic
        eprintln!();
        eprintln!("Enter your BIP-39 mnemonic phrase:");
        let mut mnemonic = String::new();
        std::io::stdin().read_line(&mut mnemonic)?;
        let mnemonic = mnemonic.trim();

        // Derive key from mnemonic at index 0
        let signing_key = hd::derive_key(mnemonic, 0)?;
        let private_key_bytes = signing_key.to_bytes();

        // Create keystore from the derived key
        let (address, _path) =
            Keystore::create_from_key(&keystore_dir, &password, &private_key_bytes)?;

        eprintln!();
        eprintln!("‚ö†Ô∏è  Store your mnemonic in a safe place. It will NOT be saved.");
        address
    } else {
        // Generate a new mnemonic
        let mnemonic = hd::generate_mnemonic();
        eprintln!();
        eprintln!("üîë Generated mnemonic (WRITE THIS DOWN ‚Äî it will NOT be shown again):");
        eprintln!();
        eprintln!("  {mnemonic}");
        eprintln!();

        // Derive key at index 0 and store
        let signing_key = hd::derive_key(&mnemonic, 0)?;
        let private_key_bytes = signing_key.to_bytes();

        let (address, _path) =
            Keystore::create_from_key(&keystore_dir, &password, &private_key_bytes)?;

        address
    };

    // Write default policy.yaml
    let policy_path = data_dir.join("policy.yaml");
    if !policy_path.exists() {
        std::fs::write(&policy_path, DEFAULT_POLICY)?;
    }

    // Write default config.yaml
    let config_path = data_dir.join("config.yaml");
    if !config_path.exists() {
        std::fs::write(
            &config_path,
            default_config(&data_dir, auth_password_hash.as_deref()),
        )?;
    }

    eprintln!();
    println!(
        "Initialized clawlet at {} ‚Äî address: {address}",
        data_dir.display()
    );

    if auth_password_hash.is_some() {
        eprintln!();
        eprintln!("üîê Authentication enabled. To grant a session token to an AI agent:");
        eprintln!("   clawlet auth grant --agent <name> --scope <read|trade|admin>");
    }

    Ok(())
}
