//! `clawlet start` â€” quick start combining init, auth grant, and serve.
//!
//! This command provides a streamlined flow for getting started:
//! 1. Initialize keystore if needed (or unlock existing)
//! 2. Grant a session token to the specified agent
//! 3. Start the HTTP JSON-RPC server

use std::net::SocketAddr;
use std::path::PathBuf;
use std::sync::{Arc, RwLock};
use std::time::Duration;

use clawlet_core::auth::{SessionStore, TokenScope};
use clawlet_core::config::Config;
use clawlet_rpc::server::DEFAULT_ADDR;
use clawlet_signer::hd;
use clawlet_signer::keystore::Keystore;
use clawlet_signer::signer::LocalSigner;

/// Default policy YAML template.
const DEFAULT_POLICY: &str = r#"# Clawlet transfer policy
# Edit this file to configure spending limits and allowlists.

daily_transfer_limit_usd: 1000.0
per_tx_limit_usd: 500.0

# Allowed token symbols (empty = all tokens allowed)
allowed_tokens: []

# Allowed chain IDs (empty = all chains allowed)
allowed_chains: []

# Transfers above this USD value require human approval (remove to disable)
require_approval_above_usd: 200.0
"#;

/// Build the default config.yaml content, pointing at the given data directory.
fn default_config(data_dir: &std::path::Path) -> String {
    let policy_path = data_dir.join("policy.yaml");
    let keystore_path = data_dir.join("keystore");
    let audit_log_path = data_dir.join("audit.jsonl");

    format!(
        r#"# Clawlet configuration
# Generated by `clawlet start`

policy_path: "{}"
keystore_path: "{}"
rpc_bind: "127.0.0.1:9100"
audit_log_path: "{}"

# Map chain IDs to RPC endpoints
# Replace with your own RPC URLs for better reliability/performance
chain_rpc_urls:
  # Ethereum Mainnet
  1: "https://eth.llamarpc.com"
  # Base
  8453: "https://mainnet.base.org"
  # Arbitrum One
  42161: "https://arb1.arbitrum.io/rpc"
  # Optimism
  10: "https://mainnet.optimism.io"
  # Polygon
  137: "https://polygon-rpc.com"
  # BNB Smart Chain
  56: "https://bsc-dataseed.binance.org"

# Authentication configuration
auth:
  default_session_ttl_hours: 24
  max_failed_attempts: 5
  lockout_minutes: 15
"#,
        policy_path.display(),
        keystore_path.display(),
        audit_log_path.display(),
    )
}

/// Resolve the data directory (default: ~/.clawlet).
fn resolve_data_dir(data_dir: Option<PathBuf>) -> Result<PathBuf, Box<dyn std::error::Error>> {
    if let Some(dir) = data_dir {
        return Ok(dir);
    }

    let home = dirs::home_dir().ok_or("could not determine home directory")?;
    Ok(home.join(".clawlet"))
}

/// Parse a duration string like "1y", "30d", "24h" into a Duration.
fn parse_duration(s: &str) -> Result<Duration, Box<dyn std::error::Error>> {
    let s = s.trim().to_lowercase();

    if let Some(years) = s.strip_suffix('y') {
        let years: u64 = years.parse()?;
        return Ok(Duration::from_secs(years * 365 * 24 * 3600));
    }
    if let Some(days) = s.strip_suffix('d') {
        let days: u64 = days.parse()?;
        return Ok(Duration::from_secs(days * 24 * 3600));
    }
    if let Some(hours) = s.strip_suffix('h') {
        let hours: u64 = hours.parse()?;
        return Ok(Duration::from_secs(hours * 3600));
    }
    if let Some(weeks) = s.strip_suffix('w') {
        let weeks: u64 = weeks.parse()?;
        return Ok(Duration::from_secs(weeks * 7 * 24 * 3600));
    }

    // Try parsing as plain seconds
    let secs: u64 = s.parse()?;
    Ok(Duration::from_secs(secs))
}

/// Run the `start` subcommand.
pub async fn run(
    agent: String,
    scope: String,
    expires: String,
    data_dir: Option<PathBuf>,
    addr: Option<SocketAddr>,
) -> Result<(), Box<dyn std::error::Error>> {
    let data_dir = resolve_data_dir(data_dir)?;
    let keystore_dir = data_dir.join("keystore");
    let config_path = data_dir.join("config.yaml");

    // Parse scope
    let token_scope: TokenScope = scope
        .parse()
        .map_err(|_| format!("invalid scope: {scope}. Use 'read', 'trade', or 'admin'"))?;

    // Parse expiry duration
    let expires_duration = parse_duration(&expires)?;

    // Check if already initialized
    let already_initialized = keystore_dir.exists() && {
        let keys = Keystore::list(&keystore_dir)?;
        !keys.is_empty()
    };

    let (signing_key, _address) = if already_initialized {
        // Already initialized - try Keychain first, then prompt
        let password = if let Some(pw) = clawlet_signer::keychain::retrieve_password() {
            eprintln!("ðŸ” Using password from Keychain");
            pw
        } else {
            eprintln!("ðŸ” Enter password: ");
            rpassword::read_password()?
        };

        let keys = Keystore::list(&keystore_dir)?;
        let (_addr, key_path) = &keys[0];
        let key = Keystore::unlock(key_path, &password)?;
        let addr = clawlet_signer::keystore::public_key_to_address(&key);

        eprintln!();
        eprintln!("âœ… Using existing keystore");
        eprintln!("   Address: {addr}");

        (key, addr)
    } else {
        // New init - ask for password with confirmation
        eprintln!("ðŸ” Enter password: ");
        let password = rpassword::read_password()?;
        eprintln!("ðŸ” Confirm password: ");
        let confirm = rpassword::read_password()?;

        if password != confirm {
            return Err("passwords do not match".into());
        }

        // Create directory structure
        std::fs::create_dir_all(&keystore_dir)?;

        // Generate new mnemonic and derive key
        let mnemonic = hd::generate_mnemonic();
        eprintln!();
        eprintln!("ðŸ”‘ Generated mnemonic (WRITE THIS DOWN â€” it will NOT be shown again):");
        eprintln!();
        eprintln!("  {mnemonic}");
        eprintln!();

        let key = hd::derive_key(&mnemonic, 0)?;
        let private_key_bytes = key.to_bytes();

        let (address, _path) =
            Keystore::create_from_key(&keystore_dir, &password, &private_key_bytes)?;

        // Write default policy.yaml
        let policy_path = data_dir.join("policy.yaml");
        if !policy_path.exists() {
            std::fs::write(&policy_path, DEFAULT_POLICY)?;
        }

        // Write default config.yaml
        if !config_path.exists() {
            std::fs::write(&config_path, default_config(&data_dir))?;
        }

        // Store password in Keychain for auto-unlock (macOS only)
        if let Err(e) = clawlet_signer::keychain::store_password(&password) {
            eprintln!();
            eprintln!("âš ï¸  Could not store password in Keychain: {e}");
            eprintln!("   You'll need to enter the password manually when starting the service.");
        } else {
            #[cfg(target_os = "macos")]
            {
                eprintln!();
                eprintln!("âœ… Password stored in macOS Keychain");
            }
        }

        eprintln!("âœ… Initialized {}", data_dir.display());
        eprintln!("   Address: {address}");

        (key, address)
    };

    // Load config
    let config = Config::from_file(&config_path)?;

    // Create session store and grant token
    let mut session_store = SessionStore::new();

    // Get current Unix UID
    #[cfg(unix)]
    let uid = unsafe { libc::getuid() };
    #[cfg(not(unix))]
    let uid = 0u32;

    // Grant the token
    let token = session_store.grant(&agent, token_scope, expires_duration, uid);
    let session = session_store.get(&agent).unwrap();
    let expires_at = session.expires_at;

    eprintln!();
    eprintln!(
        "ðŸŽ« Token for \"{}\" (scope: {}, expires: {})",
        agent,
        scope,
        expires_at.format("%Y-%m-%d")
    );
    println!("   {token}");

    // Determine listen address
    let listen_addr = addr.unwrap_or_else(|| {
        config
            .rpc_bind
            .parse()
            .unwrap_or_else(|_| DEFAULT_ADDR.parse().unwrap())
    });

    eprintln!();
    eprintln!("ðŸš€ Clawlet server running on http://{listen_addr}");
    eprintln!("   Press Ctrl+C to stop");

    // Start the server with pre-granted session
    start_server_with_session(
        &config,
        LocalSigner::new(signing_key),
        listen_addr,
        session_store,
    )
    .await?;

    Ok(())
}

/// Start the RPC server with a pre-populated session store.
async fn start_server_with_session(
    config: &Config,
    signer: LocalSigner,
    addr: SocketAddr,
    session_store: SessionStore,
) -> Result<(), Box<dyn std::error::Error>> {
    use std::collections::HashMap;
    use std::sync::Mutex;

    use clawlet_core::audit::AuditLogger;
    use clawlet_core::policy::PolicyEngine;
    use clawlet_evm::EvmAdapter;
    use clawlet_rpc::server::{AppState, ClawletApiServer, RpcServerImpl};
    use jsonrpsee::server::Server;

    // Load policy
    let policy = PolicyEngine::from_file(&config.policy_path)?;

    // Create audit logger (ensure parent dir exists)
    if let Some(parent) = config.audit_log_path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    let audit = AuditLogger::new(&config.audit_log_path)?;

    // Build EVM adapters for each configured chain
    let mut adapters = HashMap::new();
    for (chain_id, rpc_url) in &config.chain_rpc_urls {
        let adapter = EvmAdapter::new(rpc_url)?;
        adapters.insert(*chain_id, adapter);
    }

    let skills_dir = std::env::var("CLAWLET_SKILLS_DIR")
        .map(PathBuf::from)
        .unwrap_or_else(|_| PathBuf::from("skills"));

    let state = Arc::new(AppState {
        policy: Arc::new(policy),
        audit: Arc::new(Mutex::new(audit)),
        adapters: Arc::new(adapters),
        session_store: Arc::new(RwLock::new(session_store)),
        auth_config: config.auth.clone(),
        signer: Arc::new(signer),
        skills_dir,
        keystore_path: config.keystore_path.clone(),
    });

    let server = Server::builder().build(addr).await?;

    let rpc_impl = RpcServerImpl::new(Arc::clone(&state));
    let handle = server.start(rpc_impl.into_rpc());

    // Wait for server to finish (runs until stopped)
    handle.stopped().await;

    Ok(())
}
