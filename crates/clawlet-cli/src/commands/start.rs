//! `clawlet start` â€” quick start combining init, auth grant, and serve.
//!
//! This command provides a streamlined flow for getting started:
//! 1. Initialize keystore if needed (or unlock existing)
//! 2. Grant a session token to the specified agent
//! 3. Start the HTTP JSON-RPC server
//!
//! Like `serve`, the command is split into [`prepare`] (synchronous) and
//! [`start`] (asynchronous) so that daemon mode can fork in between.

use std::net::SocketAddr;
use std::path::PathBuf;
use std::time::Duration;

use clawlet_core::auth::{SessionStore, TokenScope};
use clawlet_core::config::Config;
use clawlet_rpc::server::{RpcServer, DEFAULT_ADDR};
use clawlet_signer::hd;
use clawlet_signer::keystore::Keystore;
use clawlet_signer::signer::LocalSigner;

/// Default policy YAML template.
const DEFAULT_POLICY: &str = r#"# Clawlet transfer policy
# Edit this file to configure spending limits and allowlists.

daily_transfer_limit_usd: 1000.0
per_tx_limit_usd: 500.0

# Allowed token symbols (empty = all tokens allowed)
allowed_tokens: []

# Allowed chain IDs (empty = all chains allowed)
allowed_chains: []

# Transfers above this USD value require human approval (remove to disable)
require_approval_above_usd: 200.0
"#;

/// Build the default config.yaml content, pointing at the given data directory.
fn default_config(data_dir: &std::path::Path) -> String {
    let policy_path = data_dir.join("policy.yaml");
    let keystore_path = data_dir.join("keystore");
    let audit_log_path = data_dir.join("audit.jsonl");

    format!(
        r#"# Clawlet configuration
# Generated by `clawlet start`

policy_path: "{}"
keystore_path: "{}"
rpc_bind: "127.0.0.1:9100"
audit_log_path: "{}"

# Map chain IDs to RPC endpoints
# Replace with your own RPC URLs for better reliability/performance
chain_rpc_urls:
  # Ethereum Mainnet
  1: "https://eth.llamarpc.com"
  # Base
  8453: "https://mainnet.base.org"
  # Arbitrum One
  42161: "https://arb1.arbitrum.io/rpc"
  # Optimism
  10: "https://mainnet.optimism.io"
  # Polygon
  137: "https://polygon-rpc.com"
  # BNB Smart Chain
  56: "https://bsc-dataseed.binance.org"
  # Sepolia (testnet)
  11155111: "https://ethereum-sepolia-rpc.publicnode.com"

# Authentication configuration
auth:
  default_session_ttl_hours: 24
  max_failed_attempts: 5
  lockout_minutes: 15
"#,
        policy_path.display(),
        keystore_path.display(),
        audit_log_path.display(),
    )
}

/// Resolve the data directory (default: ~/.clawlet).
fn resolve_data_dir(data_dir: Option<PathBuf>) -> Result<PathBuf, Box<dyn std::error::Error>> {
    if let Some(dir) = data_dir {
        return Ok(dir);
    }

    let home = dirs::home_dir().ok_or("could not determine home directory")?;
    Ok(home.join(".clawlet"))
}

/// Parse a duration string like "1y", "30d", "24h" into a Duration.
fn parse_duration(s: &str) -> Result<Duration, Box<dyn std::error::Error>> {
    let s = s.trim().to_lowercase();

    if let Some(years) = s.strip_suffix('y') {
        let years: u64 = years.parse()?;
        return Ok(Duration::from_secs(years * 365 * 24 * 3600));
    }
    if let Some(days) = s.strip_suffix('d') {
        let days: u64 = days.parse()?;
        return Ok(Duration::from_secs(days * 24 * 3600));
    }
    if let Some(hours) = s.strip_suffix('h') {
        let hours: u64 = hours.parse()?;
        return Ok(Duration::from_secs(hours * 3600));
    }
    if let Some(weeks) = s.strip_suffix('w') {
        let weeks: u64 = weeks.parse()?;
        return Ok(Duration::from_secs(weeks * 7 * 24 * 3600));
    }

    // Try parsing as plain seconds
    let secs: u64 = s.parse()?;
    Ok(Duration::from_secs(secs))
}

/// Everything needed to start the server, produced by [`prepare`].
pub struct PreparedStart {
    pub config: Config,
    pub signer: LocalSigner,
    pub listen_addr: SocketAddr,
    pub session_store: SessionStore,
}

/// Synchronous preparation: init/unlock keystore, grant token, load config.
///
/// Must run before daemonizing (needs interactive terminal for password prompt).
pub fn prepare(
    agent: String,
    scope: String,
    expires: String,
    data_dir: Option<PathBuf>,
    addr: Option<SocketAddr>,
) -> Result<PreparedStart, Box<dyn std::error::Error>> {
    let data_dir = resolve_data_dir(data_dir)?;
    let keystore_dir = data_dir.join("keystore");
    let config_path = data_dir.join("config.yaml");

    // Parse scope
    let token_scope: TokenScope = scope
        .parse()
        .map_err(|_| format!("invalid scope: {scope}. Use 'read', 'trade', or 'admin'"))?;

    // Parse expiry duration
    let expires_duration = parse_duration(&expires)?;

    // Check if already initialized
    let already_initialized = keystore_dir.exists() && {
        let keys = Keystore::list(&keystore_dir)?;
        !keys.is_empty()
    };

    let (signing_key, _address) = if already_initialized {
        // Already initialized - just ask for password once
        eprintln!("ðŸ” Enter wallet password: ");
        let password = rpassword::read_password()?;

        let keys = Keystore::list(&keystore_dir)?;
        let key_path = &keys[0];
        let mnemonic = Keystore::unlock(key_path, &password)?;
        let key = hd::derive_key(&mnemonic, 0)?;
        let addr = clawlet_signer::keystore::public_key_to_address(&key);

        eprintln!();
        eprintln!("âœ… Using existing keystore");
        eprintln!("   Address: {addr}");

        (key, addr)
    } else {
        // New init - ask for password with confirmation
        eprintln!("ðŸ” Enter wallet password: ");
        let password = rpassword::read_password()?;
        eprintln!("ðŸ” Confirm wallet password: ");
        let confirm = rpassword::read_password()?;

        if password != confirm {
            return Err("passwords do not match".into());
        }

        // Enforce password strength rules
        let issues = super::init::validate_password_strength(&password);
        if !issues.is_empty() {
            let mut msg = String::from("Password does not meet strength requirements:\n");
            for issue in &issues {
                msg.push_str(&format!("  - {issue}\n"));
            }
            return Err(msg.into());
        }

        // Create directory structure
        std::fs::create_dir_all(&keystore_dir)?;

        // Generate new mnemonic and derive key
        let mnemonic = hd::generate_mnemonic();
        eprintln!();
        eprintln!("ðŸ”‘ Generated mnemonic (WRITE THIS DOWN â€” it will NOT be shown again):");
        eprintln!();
        eprintln!("  {mnemonic}");
        eprintln!();

        let (address, _path) = Keystore::create_from_mnemonic(&keystore_dir, &password, &mnemonic)?;

        let key = hd::derive_key(&mnemonic, 0)?;

        // Write default policy.yaml
        let policy_path = data_dir.join("policy.yaml");
        if !policy_path.exists() {
            std::fs::write(&policy_path, DEFAULT_POLICY)?;
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                std::fs::set_permissions(&policy_path, std::fs::Permissions::from_mode(0o600))?;
            }
        }

        // Write default config.yaml
        if !config_path.exists() {
            std::fs::write(&config_path, default_config(&data_dir))?;
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                std::fs::set_permissions(&config_path, std::fs::Permissions::from_mode(0o600))?;
            }
        }

        eprintln!("âœ… Initialized {}", data_dir.display());
        eprintln!("   Address: {address}");

        (key, address)
    };

    // Load config
    let config = Config::from_file(&config_path)?;

    // Create session store with disk persistence
    let sessions_path = data_dir.join("sessions.json");
    let mut session_store = SessionStore::with_persistence(sessions_path);

    // Get current Unix UID
    #[cfg(unix)]
    let uid = unsafe { libc::getuid() };
    #[cfg(not(unix))]
    let uid = 0u32;

    // Grant the token
    let token = session_store.grant(&agent, token_scope, expires_duration, uid);
    let session = session_store.get(&agent).unwrap();
    let expires_at = session.expires_at;

    eprintln!();
    eprintln!(
        "ðŸŽ« Token for \"{}\" (scope: {}, expires: {})",
        agent,
        scope,
        expires_at.format("%Y-%m-%d")
    );
    println!("   {token}");

    // Determine listen address
    let listen_addr = addr.unwrap_or_else(|| {
        config
            .rpc_bind
            .parse()
            .unwrap_or_else(|_| DEFAULT_ADDR.parse().unwrap())
    });

    Ok(PreparedStart {
        config,
        signer: LocalSigner::new(signing_key),
        listen_addr,
        session_store,
    })
}

/// Start the server with previously prepared state (async).
pub async fn start(prepared: PreparedStart) -> Result<(), Box<dyn std::error::Error>> {
    start_notify(prepared, None).await
}

/// Start the server with previously prepared state and optional ready notification fd.
///
/// If `ready_fd` is provided, "ok\n" will be written to it after the RPC server
/// successfully binds, signaling daemon readiness to the parent process.
#[cfg(unix)]
pub async fn start_notify(
    prepared: PreparedStart,
    ready_fd: impl Into<Option<i32>>,
) -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("starting RPC server on http://{}", prepared.listen_addr);

    RpcServer::start_with_session_notify(
        &prepared.config,
        prepared.signer,
        prepared.session_store,
        Some(prepared.listen_addr),
        ready_fd.into(),
    )
    .await?;

    Ok(())
}

#[cfg(not(unix))]
pub async fn start_notify(
    prepared: PreparedStart,
    _ready_fd: impl Into<Option<i32>>,
) -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("starting RPC server on http://{}", prepared.listen_addr);

    RpcServer::start_with_session_notify(
        &prepared.config,
        prepared.signer,
        prepared.session_store,
        Some(prepared.listen_addr),
        None,
    )
    .await?;

    Ok(())
}

/// Run the `start` subcommand (non-daemon mode).
pub async fn run(
    agent: String,
    scope: String,
    expires: String,
    data_dir: Option<PathBuf>,
    addr: Option<SocketAddr>,
) -> Result<(), Box<dyn std::error::Error>> {
    let prepared = prepare(agent, scope, expires, data_dir, addr)?;

    eprintln!();
    eprintln!(
        "ðŸš€ Clawlet server running on http://{}",
        prepared.listen_addr
    );
    eprintln!("   Press Ctrl+C to stop");

    start(prepared).await
}

