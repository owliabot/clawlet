//! `clawlet start` â€” quick start combining init, auth grant, and serve.
//!
//! This command provides a streamlined flow for getting started:
//! 1. Initialize keystore if needed (or unlock existing)
//! 2. Grant a session token to the specified agent
//! 3. Start the HTTP JSON-RPC server
//!
//! Like `serve`, the command is split into [`prepare`] (synchronous) and
//! [`start`] (asynchronous) so that daemon mode can fork in between.

use std::net::SocketAddr;
use std::path::PathBuf;
use std::time::Duration;

use clawlet_core::auth::{SessionStore, TokenScope};
use clawlet_core::config::Config;
use clawlet_rpc::server::{RpcServer, DEFAULT_ADDR};
use clawlet_signer::hd;
use clawlet_signer::keystore::Keystore;
use clawlet_signer::signer::LocalSigner;

/// Default policy YAML template.
const DEFAULT_POLICY: &str = r#"# Clawlet transfer policy
# Edit this file to configure spending limits and allowlists.

daily_transfer_limit_usd: 1000.0
per_tx_limit_usd: 500.0

# Allowed token symbols (empty = all tokens allowed)
allowed_tokens: []

# Allowed chain IDs (empty = all chains allowed)
allowed_chains: []

# Transfers above this USD value require human approval (remove to disable)
require_approval_above_usd: 200.0
"#;

/// Build the default config.yaml content, pointing at the given data directory.
fn default_config(data_dir: &std::path::Path) -> String {
    let policy_path = data_dir.join("policy.yaml");
    let keystore_path = data_dir.join("keystore");
    let audit_log_path = data_dir.join("audit.jsonl");

    format!(
        r#"# Clawlet configuration
# Generated by `clawlet start`

policy_path: "{}"
keystore_path: "{}"
rpc_bind: "127.0.0.1:9100"
audit_log_path: "{}"

# Map chain IDs to RPC endpoints
# Replace with your own RPC URLs for better reliability/performance
chain_rpc_urls:
  # Ethereum Mainnet
  1: "https://eth.llamarpc.com"
  # Base
  8453: "https://mainnet.base.org"
  # Arbitrum One
  42161: "https://arb1.arbitrum.io/rpc"
  # Optimism
  10: "https://mainnet.optimism.io"
  # Polygon
  137: "https://polygon-rpc.com"
  # BNB Smart Chain
  56: "https://bsc-dataseed.binance.org"
  # Sepolia (testnet)
  11155111: "https://ethereum-sepolia-rpc.publicnode.com"

# Authentication configuration
auth:
  default_session_ttl_hours: 24
  max_failed_attempts: 5
  lockout_minutes: 15
"#,
        policy_path.display(),
        keystore_path.display(),
        audit_log_path.display(),
    )
}

/// Parse a duration string like "1y", "30d", "24h" into a Duration.
fn parse_duration(s: &str) -> Result<Duration, Box<dyn std::error::Error>> {
    let s = s.trim().to_lowercase();

    if let Some(years) = s.strip_suffix('y') {
        let years: u64 = years.parse()?;
        return Ok(Duration::from_secs(years * 365 * 24 * 3600));
    }
    if let Some(days) = s.strip_suffix('d') {
        let days: u64 = days.parse()?;
        return Ok(Duration::from_secs(days * 24 * 3600));
    }
    if let Some(hours) = s.strip_suffix('h') {
        let hours: u64 = hours.parse()?;
        return Ok(Duration::from_secs(hours * 3600));
    }
    if let Some(weeks) = s.strip_suffix('w') {
        let weeks: u64 = weeks.parse()?;
        return Ok(Duration::from_secs(weeks * 7 * 24 * 3600));
    }

    // Try parsing as plain seconds
    let secs: u64 = s.parse()?;
    Ok(Duration::from_secs(secs))
}

/// Everything needed to start the server, produced by [`prepare`].
pub struct PreparedStart {
    pub config: Config,
    pub signer: LocalSigner,
    pub listen_addr: SocketAddr,
    pub session_store: SessionStore,
}

/// Synchronous preparation: init/unlock keystore, grant token, load config.
///
/// Must run before daemonizing (needs interactive terminal for password prompt).
pub fn prepare(
    agent: String,
    scope: String,
    expires: String,
    data_dir: Option<PathBuf>,
    addr: Option<SocketAddr>,
    from_mnemonic: bool,
) -> Result<PreparedStart, Box<dyn std::error::Error>> {
    let data_dir = super::resolve_data_dir(data_dir)?;
    let keystore_dir = data_dir.join("keystore");
    let config_path = data_dir.join("config.yaml");

    // Parse scope
    let token_scope: TokenScope = scope
        .parse()
        .map_err(|_| format!("invalid scope: {scope}. Use 'read', 'trade', or 'admin'"))?;

    // Parse expiry duration
    let expires_duration = parse_duration(&expires)?;

    // Check if already initialized
    let already_initialized = keystore_dir.exists() && {
        let keys = Keystore::list(&keystore_dir)?;
        !keys.is_empty()
    };

    let (signing_key, _address) = if already_initialized {
        // Already initialized - ask for password
        let password: String =
            rpassword::prompt_password_stderr("ðŸ” è¯·è¾“å…¥é’±åŒ…å¯†ç  (Enter wallet password): ")?;

        let keys = Keystore::list(&keystore_dir)?;
        let key_path = &keys[0];
        let mnemonic = Keystore::unlock(key_path, &password)?;
        let key = hd::derive_key(&mnemonic, 0)?;
        let addr = clawlet_signer::keystore::public_key_to_address(&key);

        eprintln!();
        eprintln!("âœ… ä½¿ç”¨å·²æœ‰å¯†é’¥åº“ (Using existing keystore)");
        eprintln!("   Address: {addr}");

        (key, addr)
    } else {
        // New init â€” password in normal terminal, mnemonic in alternate screen
        let password: String =
            rpassword::prompt_password_stderr("ðŸ” è¯·è¾“å…¥é’±åŒ…å¯†ç  (Enter wallet password): ")?;
        let confirm: String =
            rpassword::prompt_password_stderr("ðŸ” ç¡®è®¤é’±åŒ…å¯†ç  (Confirm wallet password): ")?;

        if password != confirm {
            return Err("å¯†ç ä¸åŒ¹é… (passwords do not match)".into());
        }

        let issues = super::init::validate_password_strength(&password);
        if !issues.is_empty() {
            let mut msg = String::from("Password does not meet strength requirements:\n");
            for issue in &issues {
                msg.push_str(&format!("  - {issue}\n"));
            }
            return Err(msg.into());
        }

        let mnemonic = if from_mnemonic {
            eprintln!();
            eprint!("è¯·è¾“å…¥ BIP-39 åŠ©è®°è¯ (Enter your BIP-39 mnemonic phrase): ");
            let mut mnemonic_input = String::new();
            std::io::stdin().read_line(&mut mnemonic_input)?;
            let mnemonic_input = mnemonic_input.trim().to_string();
            if mnemonic_input.is_empty() {
                return Err("mnemonic cannot be empty".into());
            }
            eprintln!();
            eprintln!("ðŸ“¥ æ­£åœ¨å¯¼å…¥åŠ©è®°è¯ (Importing mnemonic)...");
            mnemonic_input
        } else {
            eprintln!();
            eprintln!(
                "ðŸ”‘ æœªæ‰¾åˆ°å¯†é’¥åº“ï¼Œæ­£åœ¨åˆ›å»ºæ–°é’±åŒ… (No keystore found, creating new wallet)..."
            );
            hd::generate_mnemonic()
        };

        // Create directory structure first so we fail before showing the mnemonic
        std::fs::create_dir_all(&keystore_dir)?;

        // If mnemonic was generated (not imported), show it in alternate screen.
        // The alternate screen ensures it's not in scroll-back.
        if !from_mnemonic {
            crate::tui::show_sensitive(
                &[
                    "ðŸ”‘ æ‚¨çš„åŠ©è®°è¯ (WRITE THIS DOWN â€” it will NOT be shown again):",
                    "",
                    &format!("  {mnemonic}"),
                ],
                "ç¡®è®¤å·²ä¿å­˜åŽæŒ‰å›žè½¦ç»§ç»­ (Press Enter when you have saved the mnemonic)...",
            )?;
        }

        let (address, _path) = Keystore::create_from_mnemonic(&keystore_dir, &password, &mnemonic)?;

        let key = hd::derive_key(&mnemonic, 0)?;

        // Write default policy.yaml
        let policy_path = data_dir.join("policy.yaml");
        if !policy_path.exists() {
            std::fs::write(&policy_path, DEFAULT_POLICY)?;
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                std::fs::set_permissions(&policy_path, std::fs::Permissions::from_mode(0o600))?;
            }
        }

        // Write default config.yaml
        if !config_path.exists() {
            std::fs::write(&config_path, default_config(&data_dir))?;
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                std::fs::set_permissions(&config_path, std::fs::Permissions::from_mode(0o600))?;
            }
        }

        eprintln!("âœ… åˆå§‹åŒ–å®Œæˆ (Initialized) {}", data_dir.display());
        eprintln!("   Address: {address}");

        (key, address)
    };

    // Load config
    let config = Config::from_file(&config_path)?;

    // Create session store with disk persistence
    let sessions_path = data_dir.join("sessions.json");
    let mut session_store = SessionStore::with_persistence(sessions_path);

    // Get current Unix UID
    #[cfg(unix)]
    let uid = unsafe { libc::getuid() };
    #[cfg(not(unix))]
    let uid = 0u32;

    // Grant the token
    let grant = session_store.grant(&agent, token_scope, expires_duration, uid);
    let token = &grant.token;
    let expires_at = grant.expires_at;

    eprintln!();
    eprintln!(
        "ðŸŽ« ä»¤ç‰Œ (Token) for \"{}\" (scope: {}, expires: {})",
        agent,
        scope,
        expires_at.format("%Y-%m-%d")
    );
    println!("   {token}");

    // Determine listen address
    let listen_addr = addr.unwrap_or_else(|| {
        config
            .rpc_bind
            .parse()
            .unwrap_or_else(|_| DEFAULT_ADDR.parse().unwrap())
    });

    Ok(PreparedStart {
        config,
        signer: LocalSigner::new(signing_key),
        listen_addr,
        session_store,
    })
}

/// Start the server with previously prepared state (async).
pub async fn start(prepared: PreparedStart) -> Result<(), Box<dyn std::error::Error>> {
    start_notify(prepared, None).await
}

/// Start the server with previously prepared state and optional ready notification fd.
///
/// If `ready_fd` is provided, "ok\n" will be written to it after the RPC server
/// successfully binds, signaling daemon readiness to the parent process.
#[cfg(unix)]
pub async fn start_notify(
    prepared: PreparedStart,
    ready_fd: impl Into<Option<i32>>,
) -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("starting RPC server on http://{}", prepared.listen_addr);

    RpcServer::start_with_session_notify(
        &prepared.config,
        prepared.signer,
        prepared.session_store,
        Some(prepared.listen_addr),
        ready_fd.into(),
    )
    .await?;

    Ok(())
}

#[cfg(not(unix))]
pub async fn start_notify(
    prepared: PreparedStart,
    _ready_fd: impl Into<Option<i32>>,
) -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("starting RPC server on http://{}", prepared.listen_addr);

    RpcServer::start_with_session_notify(
        &prepared.config,
        prepared.signer,
        prepared.session_store,
        Some(prepared.listen_addr),
        None,
    )
    .await?;

    Ok(())
}

/// Run the `start` subcommand (non-daemon mode).
pub async fn run(
    agent: String,
    scope: String,
    expires: String,
    data_dir: Option<PathBuf>,
    addr: Option<SocketAddr>,
    from_mnemonic: bool,
) -> Result<(), Box<dyn std::error::Error>> {
    let prepared = prepare(agent, scope, expires, data_dir, addr, from_mnemonic)?;

    // Stop any existing instance *after* prepare succeeds, so a failed
    // prepare (wrong password, config error) doesn't kill the running daemon.
    #[cfg(unix)]
    {
        let dd = prepared
            .config
            .keystore_path
            .parent()
            .unwrap_or(std::path::Path::new("."));
        match super::stop::stop_running_instance(dd, false) {
            Ok(Some(pid)) => eprintln!("Stopping existing clawlet (PID {pid})..."),
            Ok(None) => {}
            Err(e) => {
                if matches!(&e, super::stop::StopError::CannotVerify { .. }) {
                    eprintln!("warning: {e}");
                    eprintln!("Run `clawlet stop --force` first, then retry.");
                }
                return Err(e.into());
            }
        }
    }

    eprintln!();
    eprintln!(
        "ðŸš€ Clawlet server running on http://{}",
        prepared.listen_addr
    );
    eprintln!("   Press Ctrl+C to stop");

    start(prepared).await
}
